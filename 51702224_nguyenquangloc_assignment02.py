# -*- coding: utf-8 -*-
"""51702224_NguyenQuangLoc_Assignment02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12_ne4pFtKp1jEpVffu0vT-7-h3k1cMOV

Setup pyspark
"""

!pip install pyspark
!pip install -U -q PyDrive
!apt install openjdk-8-jdk-headless -qq
import os
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# Authenticate and create the PyDrive client
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

# Commented out IPython magic to ensure Python compatibility.
# Let's import the libraries we will need
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

import pyspark
from pyspark.sql import *
from pyspark.sql.functions import *
from pyspark import SparkContext, SparkConf

# create the session
conf = SparkConf().set("spark.ui.port", "4050")

# create the context
sc = pyspark.SparkContext(conf=conf)
spark = SparkSession.builder.getOrCreate()

!wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip
!unzip ngrok-stable-linux-amd64.zip
get_ipython().system_raw('./ngrok http 4050 &')
!curl -s http://localhost:4040/api/tunnels | python3 -c \
    "import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])"

"""Hướng tiếp cận: 

1.   từ mỗi user lấy ra danh sách bạn gọi là list_friends.
2.   từ mỗi friend trong list_friend ta sẽ đếm số lượng bạn => (tên_bạn: 1).
3.   cộng tất cả các cặp (tên_bạn: 1) sẽ ra bạn chung (tên_bạn: số_lượng_bạn_chung).
4.   chọn ra top 10 từ bước 3.
"""

every_things = spark.read.text('soc-LiveJournal1Adj.txt')
# every_things = spark.read.text('to_use.txt')

every_things.show()

every_things = sc.textFile('soc-LiveJournal1Adj.txt').flatMap(lambda line: line.split("\n"))
every_things.take(5)

"""=> tách từng dòng trong tập dữ liệu"""

person = every_things.map(lambda line: Row(id=line.split('\t')[0], friend= line.split('\t')[1]))
# person là kiểu dữ liệu list
person.take(5)

person = every_things.map(lambda line: line.split('\t'))
# person là kiểu dữ liệu list
person.take(5)

"""=> tách từng dòng thành các set(user, friends) 
Tham khảo tại: https://spark.apache.org/docs/1.5.2/sql-programming-guide.html
"""

schemaPerson = spark.createDataFrame(person, ['id', 'friends'])
schemaPerson.show()

"""# Bước 1: từ mỗi user lấy ra danh sách bạn gọi là list_friends.

=> Bước 1: lấy danh sách bạn từ id của người mình cần recommend bạn.
"""

schemaPerson.registerTempTable("id_person")
query = """
SELECT id, friends
FROM id_person
WHERE id = "11"
"""

temp_table = spark.sql(query )
temp_table.show()

"""=> lấy danh sách bạn từ id của người mình cần recommend bạn với tham số id_num"""

id_num = 11
query = """
SELECT friends
FROM id_person
WHERE id = "{}"
""".format(id_num)

friends_list_table = spark.sql(query )
friends_list_table.show()

"""=> Bước 2: tách `friends_list_table` ra list"""

friends_list_table.show()
flpd = friends_list_table.toPandas()

for index, rows in flpd.iterrows(): 
    list_friends =[rows.friends] 
  
list_friends = [x for x in list_friends[0].split(',')]
print(list_friends)

"""=> như vậy ta đã có danh sách những người bạn của người mình cần kiến nghị (ở đây là user có id = 11).

# Bước 2: từ mỗi friend trong list_friends ta sẽ đếm số lượng bạn => (tên_bạn: 1).

=> Bước 1: từ `list_friends` lấy ra danh sách các bạn và bạn của người đó.
"""

# tạo 1 dataframe sẵn
query = """
SELECT id, friends
FROM id_person
WHERE id = "{}"
""".format(list_friends[0])
friends_table = spark.sql(query )

# hợp dataframe có sẵn vs các dataframe tiếp theo trong list_friends
for id in list_friends[1:]:
    query = """
    SELECT id, friends
    FROM id_person
    WHERE id = "{}"
    """.format(id)
    friends_table = friends_table.union(spark.sql(query))

friends_table.show()

"""Như vậy, ta đã có 1 bảng các người bạn của user cần kiến nghị (user id = 11) và những người bạn của các người bạn đó.

Tới đây thì khá là khó hiểu đúng không? Tóm gọn lại như này: friends_table là danh sách các người bạn quen (cột id) với người  bạn ko quen (cột friends) của user 11 đó.

Ghi note: sắp tới là ta thực hiện các vòng lặp để đếm bạn vậy nên ta sẽ tạo hàm để xài dần dần.
"""

# lấy danh sách bạn vs tham số là id_num
def lay_danh_sach_ban(id_num) -> DataFrame:
    """
    id_num: số id user

    return: DataFrame chứ 1 cột (friends) chứa danh sách các người bạn.
    """
    query = """
    SELECT friends
    FROM id_person
    WHERE id = "{}"
    """.format(id_num)

    friends_list_table = spark.sql(query )
    return friends_list_table

# lấy ra kiểu list các danh sách bạn của user id
def lay_list_ban(friends_list_table, your_id) -> list:
    """
    friends_list_table: DataFrame lấy từ hàm lay_danh_sach_ban()

    return: list_friends là kiểu list chứa danh sách các người bạn
    """
    flpd = friends_list_table.toPandas()
    temp = []
    for index, rows in flpd.iterrows(): 
        temp = [rows.friends]
    
    list_friends = []
    for x in temp[0].split(','):
        list_friends.append(x)
    try:
        list_friends.remove(str(your_id))
    except ValueError:
        pass
    return list_friends

# tạo 1 DataFrame các bạn và các bạn chung của id
# tạo 1 dataframe sẵn
def tao_dataframe_chung(list_friends) -> DataFrame:
    """
    list_friends: kiểu list các người bạn (lấy từ hàm lay_list_ban)

    return: DataFrame chứa id bạn và danh sách các người bạn của họ
    """
    query = """
    SELECT id, friends
    FROM id_person
    WHERE id = "{}"
    """.format(list_friends[0])
    friends_table = spark.sql(query )

    # hợp dataframe có sẵn vs các dataframe tiếp theo trong list_friends
    for id in list_friends[1:]:
        query = """
        SELECT id, friends
        FROM id_person
        WHERE id = "{}"
        """.format(id)
        friends_table = friends_table.union(spark.sql(query))

    return friends_table

# lấy ra dạng list các danh sách id
def lay_id_ban(friends_table) -> list:
    """
    friends_table: DataFrame chứa danh sách bạn của mình và bạn của họ (cột id, cột friends)

    return: list_friends là kiểu list chứa danh sách id các người bạn
    """
    flpd = friends_table.toPandas()

    list_friends = flpd['id'].to_list()
    return list_friends

from collections import Counter 

# lấy top n bạn có bạn chung nhiều nhất
def lay_top(count_to_recommend, n=10):
    """
    count_to_recommend: là một dictionary chứa (id_bạn: số _lượng)
    n: chọn ra n phần tử có số_lượng lớn nhất

    return: top n giá trị lớn nhất trong bộ đếm.
    """
    k = Counter(count_to_recommend)
    top = k.most_common(n)
    return top

# kiến nghị n người bạn cho user id_num
def kien_nghi_n_ban_cho(id_num, n):
    """
    id_num: id của người cần kiến nghị
    n: số lượng người bạn cần kiến nghị.

    return: kiểu string danh sách những người kiến nghị cho id_num, format:
    <user><TAB><recommended>
    return a: kiểu dict top n bạn có số lượng bạn chung nhiều nhất
    """
    # lấy danh sách friends của id_num
    danh_sach_ban = lay_danh_sach_ban(id_num)
    # print(danh_sach_ban)
    list_ban = lay_list_ban(danh_sach_ban, id_num)

    # tạo dataframe chung
    df_chung = tao_dataframe_chung(list_ban)

    # lấy danh sách id của mỗi người bạn
    list_id = lay_id_ban(df_chung)

    # tạo bộ đếm
    count_to_recommend = {}

    # xét từng id trong danh sách bạn của user id_num
    for id in list_id:
        temp_df = lay_danh_sach_ban(id)
        list_ban = lay_list_ban(temp_df, id_num)
        for ban in list_ban:
            if ban not in list_id:
                if ban not in count_to_recommend:
                    count_to_recommend[ban] = 1
                else:
                    count_to_recommend[ban] += 1

    a = lay_top(count_to_recommend, n)
    list_a = []
    for i in a:
        list_a.append(i[0])
    b = ', '.join(list_a)
    print('{}\t{}'.format(id_num, b))
    return a

def brain_function(id_need_friends, top_n):
    """
    id_need_friends: kiểu list chứa danh sách đầu vào gồm nhiều user cần được recommend kết bạn
    top_n: số người sẽ kiến nghị kết bạn cho user

    return: in ra danh sách kiến nghị kết bạn 
    """
    for _id_ in id_need_friend:
        a = kien_nghi_n_ban_cho(_id_, top_n) 

    print('\n')
    return

"""=> Bước 2: bắt tay vào làm."""

_id_n_friends = 11
top_n = 10
a = kien_nghi_n_ban_cho(_id_n_friends, top_n)

"""=> OK! tới đây chúng ta đã có dc danh sách recommend cho user id 11 rồi, hãy so với kết quả trong đề nhé.

=> Để biết các recommend đó có bao nhiêu bạn chung, hay làm một vài thao tác với biến `top` dc trả về nha
"""

for i in a:
    print('{}: {}'.format(i[0], i[1]))

"""Lưu ý: kết quả chạy ra có thể khác trong đề, nhưng vẫn đảm bảo đúng 99,69% nhé, vì chọn ra top 10, tùy lúc chạy và cách xét khác nhau sẽ cho ra kết quả khác nhau, để biết thêm chi tiết ta có thể nâng lên thành top 20, và kết quả trong đề hoàn toàn trùng khớp **KHÔNG TRƯỢT PHÁT NÀO**.

# Bước 3: tiến hành chạy chương trình cho các user khác.

=> Vì ở bước 2 ta đã xây dựng một kho hàm để tính, vậy nên ở bước này ta chỉ cần bấm và ngồi chờ kết quả.

Để biết thời gian chạy hàm, t thử dùng % time để kiểm tra xem sao
"""

# Commented out IPython magic to ensure Python compatibility.
id_need_friend = [27552, 7785, 27573, 27574, 27589, 27590, 27600, 27617, 27620, 27667]
top_n = 10
# %time brain_function(id_need_friend, top_n)

"""=> trong lúc chờ đợi con rùa tên là kiến nghị kết bạn chạy thì hãy thử suy nghĩ về các hướng tiếp cận khác nhau cho con rùa này chạy nhé.

=> OK! vậy là mất gần 5m để con rùa chạy xong :))

=> Ta thấy, chỉ với 10 người mà đã mất 5m, vậy với 100 người sẽ xấp xỉ 50m, và 1000 người sẽ tương đương gần bằng 8h 20m. Như vậy, thuật toán trên vẫn chưa hoàn thiện, ta cần các thuật toán khác hiệu quả và có hiệu suất tối ưu hơn.

P/s: con rùa chạy chậm quá @.@
"""